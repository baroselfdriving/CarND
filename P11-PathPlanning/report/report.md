# Project 11: Path Planning
Self-Driving Car Engineer Nanodegree Program (Term 3)
---
## Executive Summary
The submitted source code implements an autonomous path planner for a simulated car on a 3-lane highway. As shown in the image below, the car is able to continuously drive without incident multiple loops around the track. Incidents to consider included collisions, departing lanes inadvertently, exceeding acceleration and jerk limits (10m/s<sup>2</sup> and 10 m/s<sup>3</sup>, respectively), and exceeding speed limit of 50 miles per hour.

![autonomous path planning](https://github.com/cvilas/CarND/blob/master/P11-PathPlanning/report/media/t3p1-noIncident.png "Driving without incident for multiple loops")

The following video (link: https://youtu.be/-0TvdNeugxE) shows a short segment of a run where the car demonstrates autonomous lane changes upon encountering traffic on its current lane

[![autonomous lane change demo](http://img.youtube.com/vi/-0TvdNeugxE/0.jpg)](http://www.youtube.com/watch?v=-0TvdNeugxE)

The rest of this report describes my approach to implementing the path planning solution.

## Components and Approach
Udacity provided some starter code consisting of helper functions and code to interface with the simulator. Also provided was data file consisting of waypoints spaced roughly 30 meters apart around a simulated track about 6945 meters long. The assigned speed limit was 50 miles/hour. These system wide constants are encoded in `constants.h`.

The key component which took most time to implement was the trajectory generator, which I describe first. A bicycle model provides car kinematics, and steering angle and acceleration are set by a PID controller. Lane changes are commanded from a behaviour planning unit, which relies on a prediction unit that estimates the location of other vehicles around the autonomous car.

### Trajectory Planner
Implemented in `trajectory_planner.cpp`, the primary function of the trajectory generator is to create a reference trajectory that keeps the vehicle safe from _incidents_ (mentioned previously) when in its _own lane_. Departing from the approach proposed in the project walkthough, rather than directly using a spline, I implemented the reference trajectory as a quintic polynomial on the Frenet coordinates. Since the objective is to maintain the vehicle as close to the speed limit as possible, the polynomial generates reference _speed_ rather than position along the track, which is numerically integrated to generate reference positions in Frenet coordinates. Another quintic polynomial generates reference lateral position (one of three lanes) of the vehicle. At this point, I realised the need for a locally smooth set of waypoints around the current location of the car, which was generated by spline fitting originally provided track waypoints (see `TrajectoryPlanner::updateLocalWaypoints`). This ensured that the reference trajectory when converted from Frenet into Cartesian coordinates did not cause sudden large changes in heading at waypoints. Sudden heading changes could otherwise cause lateral acceleration limits to be exceeded.

The following graph shows evolution of speed, acceleration and jerk on the Frenet 's' coordinate during initial start of the vehicle, showing a smooth ramp up of speed until target speed of about 20 m/s (90% of speed limit)

![startup trajectory path planning](https://github.com/cvilas/CarND/blob/master/P11-PathPlanning/report/media/startup_trajectory.png "Start-up trajectory in the Frenet 's' coordinate")

The trajectory generator responds to other vehicles on the lane by lowering reference speed such that the autonomous car maintains a separation of `MIN_RESPONSE_TIME` seconds (3 - 5 seconds is good, according to safe motoring websites). 

### Vehicle Model
### Prediction
### Behaviour Planning

## Reflection

# Report points

- Tragen polynomial in frenet coords. Generate for velocity rather than position.
- Numerical integration.
- Graph showing trajectory for unobstructed lane change
- Problem with generating trajectories in frenet coords for bendy roads where acc constraints can be crossed for straight frenet segments
- Modified spline lib
- vehicle model used and control inputs
- Error formulation and PID control for speed and steering - mainly for containing lateral accelerations. Gains are
  tuned for gentle control changes.
- prediction logic - constant velocity constant lane. highly conservative, but still not perfect. Low speed
  collisions are possible
- using min_response_time as the criterion for speed control and lane changes (based on safe driving heuristics)
- behaviours cost functions and weights
- Brief description of classes and functionality

- Limitations
  - Requires 3 seconds response time. If vehicle barges into path with less than 3 sec to collision,
  collision cannot be averted.
  - Only considers changing into the next nearest lane
  - Conservative unspohisticated motion model for predictions
  - conservative lane change strategy. First priorty is to stay safe within the current lane
